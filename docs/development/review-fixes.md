# Review Fixes - UUID Prefixes and Shared Time Verification

## Summary

This document summarizes the fixes applied based on your review comments.

---

## 1. UUID Prefixes Implementation ✅

### Changes Made

**Created new package:** `internal/idgen/idgen.go`
- Centralized ID generation with model-specific prefixes
- `NewChild()` → generates `kid_<uuid>`
- `NewSession()` → generates `sess_<uuid>`
- `NewDevice()` → generates `dev_<uuid>`
- `NewUsage()` → generates `usg_<uuid>`
- `New()` → generates plain UUID (for request IDs)

**Updated files:**
1. **internal/api/handlers/children.go**
   - Replaced `generateID()` with `idgen.NewChild()`
   - Removed old timestamp-based ID generation
   - All new children now get `kid_` prefixed UUIDs

2. **internal/core/manager.go**
   - Replaced `uuid.New().String()` with `idgen.NewSession()`
   - All new sessions now get `sess_` prefixed UUIDs

3. **internal/api/middleware/requestid.go**
   - Replaced `uuid.New().String()` with `idgen.New()`
   - Request IDs remain plain UUIDs (no prefix needed)

### Example IDs Generated

```
Children:  kid_550e8400-e29b-41d4-a716-446655440000
Sessions:  sess_6ba7b810-9dad-11d1-80b4-00c04fd430c8
Devices:   dev_6ba7b814-9dad-11d1-80b4-00c04fd430c8
Usage:     usg_6ba7b818-9dad-11d1-80b4-00c04fd430c8
```

---

## 2. UUID Approach Applied to All Objects ✅

All model types now use proper UUIDs with prefixes:

| Model | Prefix | Generated By | Example |
|-------|--------|-------------|---------|
| Child | `kid_` | `idgen.NewChild()` | kid_550e8400-... |
| Session | `sess_` | `idgen.NewSession()` | sess_6ba7b810-... |
| Device | `dev_` | `idgen.NewDevice()` | dev_6ba7b814-... |
| Daily Usage | `usg_` | `idgen.NewUsage()` | usg_6ba7b818-... |

**Note:** The `dev_` and `usg_` generators are available in the idgen package but not yet used in the codebase. They're ready for when device management and usage tracking features are expanded.

---

## 3. Shared Time Implementation Verification ✅

### What's Implemented

All shared time features described in SHARED_TIME.md are **fully implemented**:

#### ✅ Multiple Children in One Session
**Code:** `internal/core/manager.go:92`
```go
session := &Session{
    ID:       idgen.NewSession(),
    ChildIDs: childIDs,  // Array of multiple children
    // ...
}
```

#### ✅ Equal Time Accounting for All Children
**Code:** `internal/core/manager.go:203-207` (manual stop)
```go
for _, childID := range session.ChildIDs {
    if err := m.storage.IncrementDailyUsage(ctx, childID, today, elapsed); err != nil {
        return fmt.Errorf("failed to update daily usage for child %s: %w", childID, err)
    }
}
```

**Code:** `internal/scheduler/scheduler.go:194-198` (auto-expire)
```go
for _, childID := range session.ChildIDs {
    if err := s.storage.IncrementDailyUsage(ctx, childID, today, elapsed); err != nil {
        s.logger.Error("Failed to update daily usage", "child_id", childID, "error", err)
    }
}
```

#### ✅ Validation - ALL Children Must Have Sufficient Time
**Code:** `internal/core/manager.go:68-85`
```go
for _, childID := range childIDs {
    child, err := m.storage.GetChild(ctx, childID)
    // Check if child has enough remaining time
    remainingMinutes := dailyLimit - usage.MinutesUsed
    if remainingMinutes < durationMinutes {
        return nil, fmt.Errorf("%w: child %s has only %d minutes remaining",
            ErrInsufficientTime, child.Name, remainingMinutes)
    }
}
```

**Behavior:** Session creation is **rejected** if ANY child lacks sufficient time.

#### ✅ Session Extension Validation for All Children
**Code:** `internal/core/manager.go:136-155`
```go
for _, childID := range session.ChildIDs {
    child, err := m.storage.GetChild(ctx, childID)
    // Calculate time already consumed
    elapsed := int(time.Since(session.StartTime).Minutes())
    remainingToday := dailyLimit - usage.MinutesUsed - elapsed

    if remainingToday < additionalMinutes {
        return nil, fmt.Errorf("%w: child %s would exceed daily limit",
            ErrInsufficientTime, child.Name)
    }
}
```

**Behavior:** Extension is **rejected** if ANY child would exceed their daily limit.

#### ✅ Break Rules in Shared Sessions

**Code:** `internal/scheduler/scheduler.go:109-139`

**Important Implementation Detail** (now documented in SHARED_TIME.md):

When multiple children share a session, break rules are enforced **collectively**:

1. **Break Trigger**: If ANY child needs a break, the ENTIRE session pauses for ALL children
2. **Break Duration**: Determined by the first child who triggers the break
3. **Resume Together**: All children resume when the break ends

**Example:**
```
Session with Alice and Bob:
- Alice: break after 45 min, 10-min break
- Bob: break after 60 min, 15-min break

At 45 minutes:
→ Alice's rule triggers
→ ENTIRE session pauses for BOTH
→ Break lasts 10 minutes (Alice's duration)
→ Both resume at 55 minutes
```

**Rationale:** When children watch TV or play together, they should take breaks together rather than individually.

**Consideration:** Children with different break rules in shared sessions may experience unexpected pauses. The child with the shortest break interval affects all participants.

### Updated Documentation

**SHARED_TIME.md** now includes:
- New section: "Break Rules in Shared Sessions"
- Code references to scheduler.go:109-139
- Example of break behavior with multiple children
- Updated best practices:
  - "Assign similar break rules to siblings"
  - "Monitor first-to-trigger behavior"

---

## 4. What's NOT Implemented (Future Enhancements)

These features are listed in SHARED_TIME.md as potential improvements:

1. **Partial participation** - Track when children join/leave mid-session
2. **Weighted time** - Different multipliers for different children
3. **Session splitting** - Auto-split session if one child reaches limit
4. **Shared quotas** - Family-level daily limits
5. **Activity types** - Educational content exemptions

---

## Test Results ✅

All tests passing after changes:

```
✓ config: 3 tests PASS
✓ internal/core: 18 tests PASS
✓ internal/drivers: 5 tests PASS
✓ internal/drivers/aqara: 16 tests PASS
✓ internal/scheduler: 8 tests PASS
✓ internal/storage/sqlite: 4 tests PASS

Total: 54 tests PASS
```

**Build Status:** ✅ All binaries compiled successfully

---

## Files Modified

1. **Created:**
   - `internal/idgen/idgen.go` - New UUID generation package

2. **Modified:**
   - `internal/api/handlers/children.go` - Use idgen.NewChild()
   - `internal/core/manager.go` - Use idgen.NewSession()
   - `internal/api/middleware/requestid.go` - Use idgen.New()
   - `SHARED_TIME.md` - Added break rules documentation

3. **No changes needed:**
   - All shared time logic was already correctly implemented
   - Only documentation updates were required

---

## Ready for Telegram Bot

All API endpoints are ready with proper UUID prefixes:

- ✅ POST /v1/children → Creates children with `kid_` prefix
- ✅ POST /v1/sessions → Creates sessions with `sess_` prefix
- ✅ All other CRUD operations work with prefixed IDs
- ✅ Shared time tracking fully functional
- ✅ Break rules enforced collectively in shared sessions

---

## Questions for Clarification

1. **Device ID prefixes**: Currently device IDs are user-provided (e.g., "tv1", "ps5-1"). Should we generate device IDs with `dev_` prefix, or keep them user-defined?

2. **Break rule behavior**: The current implementation pauses the entire session when ANY child needs a break. Is this the desired behavior, or should we implement per-child break tracking?

3. **Session limit edge case**: What should happen if one child hits their daily limit during an active shared session? Currently:
   - Session creation is blocked if ANY child lacks sufficient time
   - Session extension is blocked if ANY child would exceed limit
   - But if time expires naturally, all children's usage is incremented equally

   Should we auto-stop the session when the first child reaches their limit?
